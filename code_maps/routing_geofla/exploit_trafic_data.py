#!/usr/bin/python
# -*- coding: utf-8 -*-

import add_to_path
from add_to_path import path_data
import os, sys
import json
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import matplotlib.cm as cm
from matplotlib.collections import PatchCollection
import matplotlib.font_manager as fm
#import shapefile
from mpl_toolkits.basemap import Basemap
from shapely.geometry import Point, Polygon, MultiPoint, MultiPolygon, shape
from shapely.prepared import prep
from descartes import PolygonPatch
#from pysal.esda.mapclassify import Natural_Breaks as nb
from matplotlib import colors

def dec_json(chemin):
  with open(chemin, 'r') as fichier:
    return json.loads(fichier.read())

def enc_json(database, chemin):
  with open(chemin, 'w') as fichier:
    json.dump(database, fichier)

path_built = os.path.join(path_data, 'data_maps', 'data_built')

# #############
# FRANCE MAP
# #############

# excludes Corsica
x1 = -5.
x2 = 9.
y1 = 42
y2 = 52.

# Lambert conformal for France (as suggested by IGN... check WGS84 though?)
m_fra = Basemap(resolution='i',
                projection='lcc',
                ellps = 'WGS84',
                lat_1 = 44.,
                lat_2 = 49.,
                lat_0 = 46.5,
                lon_0 = 3,
                llcrnrlat=y1,
                urcrnrlat=y2,
                llcrnrlon=x1,
                urcrnrlon=x2)

path_dir_120 = os.path.join(path_data, 'data_maps', 'ROUTE120_WGS84')

ls_files_120 = [('TRONCON_ROUTE', 'routes'),
                ('NOEUD_ROUTIER', 'noeuds'),
                ('COMMUNE', 'communes'),
                ('RATTACHEMENT_COMMUNE', 'rat_com')]

for file_120_orig, file_120_dest in ls_files_120:
  m_fra.readshapefile(os.path.join(path_dir_120, file_120_orig),
                      file_120_dest,
                      color = 'none',
                      zorder = 2)


# Collect A1 - A89 and check order (extend to all highways using CLASS_ADM) 
# (shape_info['CLASS_ADM'] == 'Autoroute') &\
dict_hws = {}
for hw_ind in range(1, 90):
  hw_name = 'A{:d}'.format(hw_ind)
  ls_hw_inds = [i for i, shape_info in enumerate(m_fra.routes_info)\
                  if (shape_info['NUM_ROUTE'] == hw_name)]
  if ls_hw_inds:
    dict_hws[hw_name] = ls_hw_inds

# Length of highways
print u'\nHighway lengths (km):'
for hw_name, ls_hw_inds in dict_hws.items():
  longueur = 0
  for hw_ind in ls_hw_inds:
    longueur += m_fra.routes_info[hw_ind]['LONGUEUR']
  print hw_name, longueur

# Order of segments
print u'\nHighway segments: ordered in original list?'
for hw_name, ls_hw_inds in dict_hws.items():
  if all(m_fra.routes[hw_ind][0] == m_fra.routes[ls_hw_inds[i-1]][-1]\
           for i, hw_ind in enumerate(ls_hw_inds[1:], start = 1)):
    print hw_name, ': ordered (simple)'
  else:
    check = True
    ls_ordered_segments = [m_fra.routes[ls_hw_inds[0]]]
    for i, hw_ind in enumerate(ls_hw_inds[1:], start = 1):
      if (m_fra.routes[hw_ind][0] == ls_ordered_segments[-1][-1]):
        ls_ordered_segments.append(m_fra.routes[hw_ind])
      elif (m_fra.routes[hw_ind][-1] == ls_ordered_segments[-1][-1]):
        ls_ordered_segments.append(m_fra.routes[hw_ind][::-1])
      else:
        print hw_name, ': not ordered'
        check = False
        break
    if check:
      print hw_name, ': ordered (some segments are reverse)'

# DRAW HIGHWAY: A51 has several pieces... probably parts are not Highway
fig = plt.figure(facecolor = 'white')
ax = fig.add_subplot(111, aspect = 'equal') #, frame_on = False)
for shape, shape_info in zip(m_fra.routes, m_fra.routes_info):
  if (shape_info['CLASS_ADM'] == 'Autoroute') &\
     (shape_info['NUM_ROUTE'] == 'A50'):
    xx, yy = zip(*shape)
    temp = ax.plot(xx, yy, linewidth = 0.5, color = 'k')
ax.autoscale_view(True, True, True)
ax.axis('off')
ax.set_axis_bgcolor('red')
plt.tight_layout()
plt.show()

## TRY TO UNDERSTAND HIGHWAY ORDER
#print u'\nInspect order of some unordered highway'
#ls_hw_inds = dict_hws['A50']
#for i, hw_ind in enumerate(ls_hw_inds[1:], start = 1):
#  if m_fra.routes[hw_ind][0] == m_fra.routes[ls_hw_inds[i-1]][-1]:
#    print hw_ind, 'True'
#  else:
#    print hw_ind,'Wrong', m_fra.routes[hw_ind], m_fra.routes[ls_hw_inds[i-1]]

## tdo: make systematic search, lost enough time (need a while... recursive)
#ls_hw_inds = dict_hws['A50']
#ls_hw_inds_ordered = [ls_hw_inds[0]]
#for i, hw_ind_i in enumerate(ls_hw_inds):
#  for j, hw_ind_j in enumetate(ls_hw_inds[i:], start = i):
#    if (m_fra.routes[hw_ind_i][0] == m_fra.routes[hw_ind_j][-1]) or\
#       (m_fra.routes[hw_ind_i][0] == m_fra.routes[hw_ind_j][0]))
#      ls_hw_inds_ordered = [hw_ind_j] + ls_hw_inds_ordered
#    elif (m_fra.routes[hw_ind_i][-1] == m_fra.routes[hw_ind_j][-1]) or\
#         (m_fra.routes[hw_ind_i][-1] == m_fra.routes[hw_ind_j][0]))
#      ls_hw_inds_ordered + ls_hw_inds_ordered + [hw_ind_j]

